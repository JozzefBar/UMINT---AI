clear;  clc;% disp('Projekt - Kohonenove siete - Metoda Euklidova vzdialenost ');% file = input('Zadaj vstupny subor pre trenovanie(vzorky.pat) : ','s');% disp(' ');% subor = fopen(file,'r');% vzorky = fscanf(subor,'%f');  %nacitanie jednotlivych vzoriek zo suboruload databody1% Nacitavanie vstupnych dat klikanim na platno% ...........................................% but = 1;% n=1;% while but == 1%    [xi, yi, but] = ginput(1);%    x(n,1)=xi;%    y(n,1)=yi;%    plot(x,y,'x');%    axis([0 1 0 1])%    n=n+1;% end% close;% ...........................................% load body_kruhpermutacia = randperm(length(x));        % permutacia cisel od 1 po dlzku polax = x( permutacia );           % Dolezite je zamiesat y = y( permutacia );           % vstupne data !figureplot(x,y,'x')  % vykreslenie vstupnych krizikov% riadky = input('Zadaj pocet riadkov (x suradnice):');   %nacitanie vstupnych udajov% stlpce = input ('Zadaj pocet stlpcov (y suradnice):');riadky = 3;stlpce = 3;%nacitanie vstupnych udajov% counter = input('Zadaj pocet cyklov ucenia :');counter = 12;       % pocet cyklovgama1 = 0.8;      % zaciatocny krok uceniar1 = 10;        % polomer susedtsvah1 = 1;         % vyska funkcie susedstvadisp(' ');%nahodna inicializacia vah%t=[-1:0.01:1]; %iny sposob inicializacie%d=cos(t);%nahod=ceil(rand(stlpce*riadky,1)*length(d));nahod=ceil(rand(stlpce*riadky,1)*length(x));g=1;for j=1:stlpce    for i=1:riadky        w1(i,j)=x(nahod(g,1),1) ;        w2(i,j)=y(nahod(g,1),1) ;        g=g+1;    endend%figure(1) %vykreslenie nahodnej inicializacieplot(x,y,'*b',w1,w2,'*r');for i=1:stlpce    x_pom=w1(:,i);    y_pom=w2(:,i);    line(x_pom,y_pom);endfor i=1:riadky    x_pom=w1(i,:);    y_pom=w2(i,:);    line(x_pom,y_pom);endtitle(' Graf pociatocnej inicializacie');%legend('trenovacie vzorky','inicializovane vahy');xlabel('x');ylabel('y');hold on;shg;pause(1);% disp(' Prebieha proces ucenia');for p=1:counter              %zaciatok zadanych cyklov ucenia    gama =exp((gama1)/p)-1;      %vypocet uciaceho sa parametra    h=exp((-h1+1)/p);      %vypocet vysky adaptácie    r=r1*exp(-p);            %vypocet polomeru priestoroveho susedstva    for k = 1:length(x)        out = (w1-x(k)).^2 + (w2-y(k)).^2; %vypocet hodnoty vystupneho neuronu        vitaz = out(1,1);        %pociatocny vitaz        vit_x=1;        vit_y=1;        for j=1:stlpce             %hladanie vitaza prejdenim vsetkych hodnot            for i=1:riadky                if out(i,j)<vitaz    %hladanie minima                    vitaz = out(i,j);                    vit_x=i;                    vit_y=j;                end                out(i,j)=0;       %vsetkych ostatnych nastavim na nulu            end        end        out(vit_x,vit_y)=1;     %vitaza nastavim na jednotku        %Nastava zmena vah k vitazovi        for i=1:riadky            for j=1:stlpce                d=(vit_x-i).^2 + (vit_y-j).^2;                lambda = h * exp(-d/r);          %urcenie lambdy                w1(i,j)=w1(i,j)+gama*lambda*(x(k)-w1(i,j));                w2(i,j)=w2(i,j)+gama*lambda*(y(k)-w2(i,j));            end        end        figure(2)        cla    %Vykreslenie priebehu ucenia v kazdom k kroku        title(' Graf priebehu ucenia');        xlabel('x');        ylabel('y');                % vykreslenie spajacich ciar        for i=1:riadky            x_pom = w1(i,:);            y_pom = w2(i,:);            line(x_pom,y_pom);        end        for i=1:stlpce            x_pom = w1(:,i);            y_pom = w2(:,i);            line(x_pom,y_pom);        end        hold on;                % ---------Roztriedenie do skupin a vykreslenie-----------        if(p==counter && k==length(x))            col=hsv(riadky*stlpce);                                       % vytvorenie farebnej palety            n=0;            skupiny = roztried(w1,w2,x,y);                                  % skupiny bodov podla suradnic neuronov v matici v tvare [w1 w2]            for i=1:riadky                for j=1:stlpce                   n=n+1;                   indexy_x = find(skupiny(:,1) == i);                      % indexy bodov v poli patriaceho do skupiny pre                    indexy_y = find(skupiny(:,2) == j);                      % [i,j]-ty neuron                   body_v_skupine= intersect(indexy_x, indexy_y);                                                    % vykresli iba body z urcitej skupiny rovnakou farbou                   p=plot(x(body_v_skupine),y(body_v_skupine),'*');                   set(p,'Color',col(n,:));                   p=plot(w1(i,j),w2(i,j),'o','MarkerEdgeColor','k','MarkerFaceColor',col(n,:),'MarkerSize',7);                                      hold on;                end            end                    else           plot(x,y,'*b',w1,w2,'*r');           hold on;        end        %---------------------------------------------                 % ---------------- Nakresli elipsy okolo neuronov --------%         for i=1:riadky%             for j=1:stlpce%                 rectangle('Position',[w1(i,j)-0.05,w2(i,j)-0.05,0.1,0.1],'Curvature',[1,1])%             end%         end        % --------------------------------------------------------                shg      %show graph        pause(0.01);    endend           % koniec celeho ucenia% vykreslenie priebehov parametrov ucenia v casegama = [];h = [];r = [];for p=1:counter    gama = [gama exp(gama1/p)-1];    h = [h exp((h1+1)/p)];    r = [r r1*exp(-p)];endt = [1:counter];figure(3);subplot(3,1,1);plot(t,gama);title('learning rate');xlabel('time');ylabel('gama');subplot(3,1,2);plot(t,h);title('height of neighbourhood function');xlabel('time');ylabel('h');subplot(3,1,3);plot(t,r);title('radium of neighbourhood function');xlabel('time');ylabel('r');